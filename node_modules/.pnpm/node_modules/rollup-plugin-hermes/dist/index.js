"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hermes = void 0;
const promises_1 = require("fs/promises");
const child_process_1 = require("child_process");
const path_1 = require("path");
const os_1 = require("os");
const crypto_1 = require("crypto");
function hermes(options) {
    var _a;
    options !== null && options !== void 0 ? options : (options = {});
    (_a = options.hermesPath) !== null && _a !== void 0 ? _a : (options.hermesPath = (0, path_1.join)(__dirname, "../../@aliucord/hermesc")); // node_modules/rollup-plugin-hermes/dist/../../@aliucord/hermesc
    const { hermesPath } = options;
    return {
        name: "hermes",
        async generateBundle(options, bundle) {
            var _a;
            let hermesPathExists;
            try {
                await (0, promises_1.access)(hermesPath);
                hermesPathExists = true;
            }
            catch (_b) {
                hermesPathExists = false;
            }
            if (hermesPath === undefined || !hermesPathExists) {
                this.warn("hermesc not found, skipping hermes plugin");
                return;
            }
            const outFile = (_a = options.file) === null || _a === void 0 ? void 0 : _a.split("/");
            if (!outFile)
                return;
            const file = outFile.pop();
            const bundleFile = bundle[file];
            if (!bundleFile)
                return;
            const map = bundleFile.map;
            const tmpmap = (0, path_1.join)((0, os_1.tmpdir)(), `${(0, crypto_1.randomBytes)(8).readUInt32LE(0)}.hermestmp`);
            if (map) {
                await (0, promises_1.writeFile)(tmpmap, map.toString());
            }
            let hermesc = `${hermesPath}/%OS%-bin/hermesc`;
            switch (process.platform) {
                case "win32":
                    hermesc = hermesc.replace("%OS%", "win64");
                    break;
                case "darwin":
                    hermesc = hermesc.replace("%OS%", "osx");
                    break;
                default:
                    hermesc = hermesc.replace("%OS%", "linux64");
            }
            const tempPath = (0, path_1.join)((0, os_1.tmpdir)(), `${(0, crypto_1.randomBytes)(8).readUInt32LE(0)}.bundle`);
            const args = ["-Wno-direct-eval", "-Wno-undefined-variable", "--emit-binary", "--out", tempPath];
            if (map) {
                args.push("--source-map");
                args.push(tmpmap);
            }
            await new Promise(r => {
                const process = (0, child_process_1.spawn)(hermesc, args, { stdio: "pipe" });
                process.on("exit", r);
                process.stdin.write(bundleFile.code);
                process.stdin.end();
            });
            this.emitFile({
                type: "asset",
                fileName: `${file}.bundle`,
                source: await (0, promises_1.readFile)(tempPath)
            });
            if (map) {
                await (0, promises_1.unlink)(tmpmap);
            }
            await (0, promises_1.unlink)(tempPath);
        }
    };
}
exports.hermes = hermes;
