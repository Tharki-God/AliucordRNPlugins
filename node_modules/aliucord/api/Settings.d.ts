/**
 * Casts types down to be less specific and also allow missing keys in Objects
 * CastDown<12> -> number
 */
declare type CastDown<T> = T extends number ? number : T extends string ? string : T extends boolean ? boolean : T extends Record<any, any> ? T & Record<string, any> : T;
/**
 * Settings React Hook. Will automatically rerender your component and
 * save to settings on set()
 */
export declare function useSettings<T>(settings: Settings<T>): {
    get<K extends keyof T, V extends T[K]>(key: K, defaultValue: V): CastDown<V>;
    set<K_1 extends keyof T, V_1 extends T[K_1]>(key: K_1, value: V_1): void;
};
/**
 * SettingsAPI.
 * For technical reasons, this class must be constructed using Settings.make,
 * and NOT via new.
 */
export declare class Settings<Schema> {
    readonly module: string;
    readonly snapshot: Schema;
    private constructor();
    /**
     * Construct a new Settings instance.
     * Accepts a Schema as generic argument which will be used to validate
     * and type calls to get and set
     * @param module Name of your module. Choose something meaningful as this will be used to
     *               identify your settings
     * @returns Settings Instance
     */
    static make<Schema = any>(module: string): Promise<Settings<Schema>>;
    /**
     * Get a settings item
     * @param key Key
     * @param defaultValue Default value to return in case no such setting exists
     * @returns Setting if found, otherwise the default value
     */
    get<K extends keyof Schema, T extends Schema[K]>(key: K, defaultValue: T): CastDown<T>;
    /**
     * Set a settings item
     * @param key Key
     * @param value New value
     */
    set<K extends keyof Schema>(key: K, value: Schema[K]): Promise<void>;
    /**
     * Delete a setting
     * @param key Key
     */
    delete<K extends keyof Schema>(key: K): Promise<void>;
    private _persist;
}
export {};
