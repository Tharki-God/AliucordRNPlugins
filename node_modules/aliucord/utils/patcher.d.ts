export declare type BeforePatchFn<T, R, A extends any[]> = (ctx: PatchContext<T, R, A>, ...args: A) => R | void;
export declare type AfterPatchFn<T, R, A extends any[]> = (ctx: AfterPatchContext<T, R, A>, result: R, ...args: A) => R | void;
export declare type InsteadFn<T, R, A extends any[]> = (ctx: PatchContext<T, R, A>, ...args: A) => R;
export declare type Unpatch = () => void;
export declare enum PatchPriority {
    MIN = 0,
    DEFAULT = 15,
    MAX = 30
}
declare type PatchFns<T, R, A extends any[]> = {
    before?: BeforePatchFn<T, R, A>;
    instead?: InsteadFn<T, R, A>;
    after?: AfterPatchFn<T, R, A>;
};
export declare class Patch<T, R, A extends any[]> {
    readonly priority: number;
    readonly plugin?: string | undefined;
    before: BeforePatchFn<T, R, A>;
    after: AfterPatchFn<T, R, A>;
    constructor(data: PatchFns<T, R, A>, priority?: number, plugin?: string | undefined);
}
declare class PatchContext<T, R, A extends any[]> {
    readonly thisObject: T;
    readonly args: A;
    private readonly backup;
    constructor(thisObject: T, args: A, backup: (...args: A) => R);
    private _result;
    private _error;
    /** Do not use */
    _returnEarly: boolean;
    set result(value: R | undefined);
    get result(): R | undefined;
    get error(): Error | undefined;
    set error(error: Error | undefined);
    getResultOrThrowError(): R | undefined;
    callOriginal(): R;
}
declare type AfterPatchContext<T, R, A extends any[]> = PatchContext<T, R, A> & {
    result: R;
};
export declare function unpatch<T>(obj: T | any, methodName: string, patch: Patch<T, any, any>): void;
export declare function callOriginal(func: (...args: any[]) => any, thisObj: any, ...args: any[]): any;
export declare function patch<T = any, R = any, A extends any[] = any[]>(object: T | any, name: string, patch: Patch<T, R, A>): Unpatch;
export declare function before<T = any, R = any, A extends any[] = any[]>(object: any, name: string, before: BeforePatchFn<T, R, A>, priority?: PatchPriority, plugin?: string): Unpatch;
export declare function instead<T = any, R = any, A extends any[] = any[]>(object: any, name: string, instead: InsteadFn<T, R, A>, priority?: PatchPriority, plugin?: string): Unpatch;
export declare function insteadDoNothing(object: any, name: string): Unpatch;
export declare function after<T = any, R = any, A extends any[] = any[]>(object: any, name: string, after: AfterPatchFn<T, R, A>, priority?: PatchPriority, plugin?: string): Unpatch;
export {};
